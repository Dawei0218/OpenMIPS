### 汇编指令

#### movn rd, rs, rt

    if rt ≠0 then rd <- rs

#### movz

    if rt = 0 then rd <- rs

#### mfhi rd

    rd <- hi

#### mflo rd

    rd <- lo

#### mthi rs

    hi <- rs

#### mtlo rs

    lo <- rs

#### add rd, rs, rt

    rd <- rs + rt   溢出不保存结果

#### addu rd, rs, rt

    rd <- rs + rt   不进行溢出检查，总是保存到寄存器

#### sub rd, rs, rt

    rd <- rs - rt   溢出不保存结果

#### subu rd, rs, rt

    rd <- rs - rt   不进行溢出检查，总是保存到寄存器

#### slt rd, rs, rt

    rd <- (rs < rt) 有符号比较，吧0或1保存在rd

#### sltu rd, rs, rt

    rd <- (rs < rt) 无符号比较

#### addi rt, rs, immediate

    rt <- rs + (sign_extended)immediate

#### addiu rt, rs, immediate

    rt <- rs + (sign_extended)immediate

#### slti rt, rs, immediate

    rt <- (rs < (sign_extended)immediate)

#### sltiu rt, rs, immediate

    rt<- (rs < (sign_extended)immediate)

#### clz rd, rs

    rd <- coun_leading_zeros rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“1”的位，将该位之前“0”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为0（即0x00000000），那么将32保存到地址为rd的通用寄存器中

#### rd <- coun_leading_ones rs

    rd <- coun_leading_ones rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“0”的位，将该位之前“1”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为1（即0xFFFFFFFF），那么将32保存到地址为rd的通用寄存器中

#### mul rd, rs, st

    rd <- rs × rt

#### mult rs, st

    {hi, lo} <- rs × rt
    将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数相乘，乘法结果的低32bit保存到LO寄存器中，高32bit保存到HI寄存器中

#### multu rs, st

    {hi, lo} <- rs × rt
    无符号相乘