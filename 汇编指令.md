### 汇编指令

#### movn rd, rs, rt

    if rt ≠0 then rd <- rs

#### movz

    if rt = 0 then rd <- rs

#### mfhi rd

    rd <- hi

#### mflo rd

    rd <- lo

#### mthi rs

    hi <- rs

#### mtlo rs

    lo <- rs

#### add rd, rs, rt

    rd <- rs + rt   溢出不保存结果

#### addu rd, rs, rt

    rd <- rs + rt   不进行溢出检查，总是保存到寄存器

#### sub rd, rs, rt

    rd <- rs - rt   溢出不保存结果

#### subu rd, rs, rt

    rd <- rs - rt   不进行溢出检查，总是保存到寄存器

#### slt rd, rs, rt

    rd <- (rs < rt) 有符号比较，吧0或1保存在rd

#### sltu rd, rs, rt

    rd <- (rs < rt) 无符号比较

#### addi rt, rs, immediate

    rt <- rs + (sign_extended)immediate

#### addiu rt, rs, immediate

    rt <- rs + (sign_extended)immediate

#### slti rt, rs, immediate

    rt <- (rs < (sign_extended)immediate)

#### sltiu rt, rs, immediate

    rt<- (rs < (sign_extended)immediate)

#### clz rd, rs

    rd <- coun_leading_zeros rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“1”的位，将该位之前“0”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为0（即0x00000000），那么将32保存到地址为rd的通用寄存器中

#### rd <- coun_leading_ones rs

    rd <- coun_leading_ones rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“0”的位，将该位之前“1”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为1（即0xFFFFFFFF），那么将32保存到地址为rd的通用寄存器中

#### mul rd, rs, st

    rd <- rs × rt

#### mult rs, st

    {hi, lo} <- rs × rt
    将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数相乘，乘法结果的低32bit保存到LO寄存器中，高32bit保存到HI寄存器中

#### multu rs, st

    {hi, lo} <- rs × rt
    无符号相乘

#### madd rs, rd

    {HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。此处{HI, LO}表示HI、LO寄存器连接形成的64位数，HI是高32位，LO是低32位。

#### maddu rs, rt

    {HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为无符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。

#### msub rs, rt

    {HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中

#### msubu rs, rt

    {HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为无符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中

#### div rs, rt

    {HI, LO} <- rs / rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为有符号数进行除法运算，将商保存到寄存器LO，余数保存到寄存器HI。

#### divu rs, rt

    {HI, LO} <- rs / rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为无符号数进行除法运算，将商保存到寄存器LO，余数保存到寄存器HI。

#### jr rs

    pc <- rs，将地址为rs的通用寄存器的值赋给寄存器PC，作为新的指令地址

#### jalr rs 或者jalr rd, rs

    rd <- return_address, pc <- rs，将地址为rs的通用寄存器的值赋给寄存器PC，作为新的指令地址，同时将跳转指令后面第2条指令的地址作为返回地址保存到地址为rd的通用寄存器，如果没有在指令中指明rd，那么默认将返回地址保存到寄存器$31

### j target

    pc <- (pc+4)[31,28] || target || ‘00’，转移到新的指令地址，其中新指令地址的低28位是指令中的target（也就是图8-3中的instr_index）左移两位的值，新指令地址的高4位是跳转指令后面延迟槽指令的地址高4位

### jal target

    pc <- (pc+4)[31,28] || target || ‘00’，转移到新的指令地址，新指令地址与指令j相同，不再解释。但是，指令jal还要将跳转指令后面第2条指令的地址作为返回地址保存到寄存器$31

### beq rs, rt, offset

    if rs = rt then branch，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值进行比较，如果相等，那么发生转移

### b offset

    无条件转移，b指令可以认为是beq指令的特殊情况，当beq指令的rs、rt都等于0时，即为b指令，所以在OpenMIPS实现的时候不需要特意实现b指令，只需要实现beq指令即可

### bgtz rs, offset

    if rs > 0 then branch，如果地址为rs的通用寄存器的值大于零，那么发生转移

### blez rs, offset

    if rs ≤ 0 then branch，如果地址为rs的通用寄存器的值小于等于零，那么发生转移

### bne rs, rt, offset

    if rs ≠ rt then branch，如果地址为rs的通用寄存器的值不等于地址为rt的通用寄存器的值，那么发生转移

### bltz rs, offset

    if rs < 0 then branch，如果地址为rs的通用寄存器的值小于0，那么发生转移

### bltzal rs, offset

    if rs < 0 then branch，如果地址为rs的通用寄存器的值小于0，那么发生转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31

### bgez rs, offset

    if rs ≥ 0 then branch，如果地址为rs的通用寄存器的值大于等于0，那么发生转移

### bgezal rs, offset

    if rs ≥ 0 then branch，如果地址为rs的通用寄存器的值大于等于0，那么发生转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31

### bal offset

    无条件转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31。bal指令是bgezal指令的特殊情况，当bgezal指令的rs为0时，就是bal指令，所以在OpenMIPS实现时，不用特意考虑bal指令，只要实现bgezal指令即可