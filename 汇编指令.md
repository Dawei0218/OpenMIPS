### 汇编指令

### ori rs, rt, immediate

    32-26   25-21   20-16   15-0
    001101    rs      rt    immediate
    immediate无符号扩展至32位，和rs进行或操作，保存到rt
    rt = rs | immediate

### and rd, rs, rt
    32-26   25-21   20-16   15-11   10-6        5-0
    000000    rs      rt      rd    00000      100100
    rd = rs & rd

### or rd, rs, rt

    32-26   25-21   20-16   15-11   10-6        5-0
    000000    rs      rt      rd    00000      100101
    rd <- rs | rt

### xor rd, rs, rt

    32-26   25-21   20-16   15-11   10-6        5-0
    000000    rs      rt      rd    00000      100110
    rd <- rs ^ rt

### nor rd, rs, rt

    32-26   25-21   20-16   15-11   10-6        5-0
    000000    rs      rt      rd    00000      100111
    rd <- ~(rs | rt)

### andi rt, rs, immediate

    32-26   25-21   20-16   15-0
    001100    rs      rt      immediate
    rt = rs & immediate

### xori rt, rs, immediate

    32-26   25-21   20-16   15-0
    001110    rs      rt      immediate
    rt = rs | immediate

### lui rt, immediate

    32-26       25-21     20-16       15-0
    001111      00000      rt      immediate
    rt = immediate || 16位0填充低地址

### sll rd, rt, sa

    32-26       25-21       20-16    15-11  10-6    5-0
    000000      00000        rt      rd     sa      000000
    rd = rt << sa
    左移sa位，空出来0填充

### srl rd, rt, sa

    32-26       25-21       20-16    15-11  10-6    5-0
    000000      00000        rt      rd     sa      000010
    rd = rt >> sa
    右移sa位，空出来0填充

### sra rd, rt, sa

    32-26       25-21       20-16    15-11  10-6    5-0
    000000      00000        rt      rd     sa      000011
    rd = rt >> sa
    空出来部分用rt[31]填充

### sllv rd, rt, rs

    32-26      25-21     20-16    15-11     10-6       5-0
    000000      rs        rt      rd        00000      000100
    rd = rt << rs
    左移rs，空出来0填充

### srlv rd, rt, rs

    32-26      25-21     20-16    15-11     10-6       5-0
    000000      rs        rt      rd        00000      000110
    rd = rt >> rs
    右移rs，空出来0填充

### srav rd, rt, rs

    32-26      25-21     20-16    15-11     10-6       5-0
    000000      rs        rt      rd        00000      000111
    rd = rt >> rs
    右移rs，rt[31]填充

### nop

    32-26     25-21    20-16    15-11    10-6     5-0
    000000    00000    00000    00000    00000   000000
    当成左移保存到$0里面

### ssnop

    32-26     25-21    20-16    15-11    10-6     5-0
    000000    00000    00000    00000    00000   000000
    当成左移保存到$0里面

### sync

    32-26     25-21    20-16    15-11    10-6     5-0
    000000    00000    00000    00000    00001   001111
    没有处理

### sync
    32-26     25-21    20-11     10-0
    110011    base      hint     offset
    当成左移保存到$0里面
    暂时没有处理


#### movn rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs      rt       rd    00000     001011
    if rt ≠0 then rd <- rs

#### movz

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs      rt       rd    00000     001010
    if rt = 0 then rd <- rs

#### mfhi rd

    32-26   25-21       20-16   15-11    10-6     5-0
    000000   00000      00000     rd    00000     010000
    rd <- hi

#### mflo rd

    32-26   25-21   20-16   15-11    10-6     5-0
    000000  00000   00000     rd    00000     010010
    rd <- lo

#### mthi rs

    32-26   25-21    20-16   15-11    10-6     5-0
    000000   rs      00000   00000    00000     010001
    hi <- rs

#### mtlo rs

    32-26   25-21    20-16   15-11    10-6     5-0
    000000   rs      00000   00000    00000     010011
    lo <- rs

#### add rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs       rt      rd     00000    100000
    rd <- rs + rt   溢出不保存结果

#### addu rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs       rt      rd     00000    100001
    rd <- rs + rt   不进行溢出检查，总是保存到寄存器

#### sub rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs       rt      rd     00000    100010
    rd <- rs - rt   溢出不保存结果

#### subu rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs       rt      rd     00000    100011
    rd <- rs - rt   不进行溢出检查，总是保存到寄存器

#### slt rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs       rt      rd     00000    101010
    rd <- (rs < rt) 有符号比较，吧0或1保存在rd

#### sltu rd, rs, rt

    32-26   25-21   20-16   15-11    10-6     5-0
    000000   rs       rt      rd     00000    101011
    rd <- (rs < rt) 无符号比较


#### addi rt, rs, immediate

    32-26   25-21   20-16   15-0
    001000   rs       rt     immediate
    rt <- rs + immediate
    符号扩展，溢出检查

#### addiu rt, rs, immediate

    32-26   25-21   20-16   15-0
    001001   rs       rt     immediate
    rt <- rs + immediate
    符号扩展，不检查溢出

#### slti rt, rs, immediate

    32-26   25-21   20-16   15-0
    001010   rs       rt     immediate
    rt <- (rs < immediate)
    符号扩展，有符号比较

#### sltiu rt, rs, immediate

    32-26   25-21   20-16   15-0
    001011   rs       rt     immediate
    rt<- (rs < immediate)
    符号扩展，无符号比较

#### clz rd, rs

    32-26   25-21   20-16   15-11   10-6    5-0
    011100   rs       rt     rd     00000   100000
    rd <- coun_leading_zeros rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“1”的位，将该位之前“0”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为0（即0x00000000），那么将32保存到地址为rd的通用寄存器中

#### clo rd, rs

    32-26   25-21   20-16   15-11   10-6    5-0
    011100   rs       rt     rd     00000   100001
    rd <- coun_leading_ones rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“0”的位，将该位之前“1”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为1（即0xFFFFFFFF），那么将32保存到地址为rd的通用寄存器中

#### mul rd, rs, st

    32-26   25-21   20-16   15-11   10-6    5-0
    011100   rs       rt     rd     00000   000010
    rd <- rs × rt
    低32保存到rd

#### mult rs, st

    32-26   25-21   20-16   15-11   10-6    5-0
    000000   rs       rt    00000   00000   011000
    {hi, lo} <- rs × rt
    将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数相乘，乘法结果的低32bit保存到LO寄存器中，高32bit保存到HI寄存器中

#### multu rs, st

    32-26   25-21   20-16   15-11   10-6    5-0
    000000   rs       rt    00000   00000   011001
    {hi, lo} <- rs × rt
    无符号相乘,低32bit保存到LO寄存器中，高32bit保存到HI寄存器中

#### madd rs, rd

    {HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。此处{HI, LO}表示HI、LO寄存器连接形成的64位数，HI是高32位，LO是低32位。

#### maddu rs, rt

    {HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为无符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。

#### msub rs, rt

    {HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中

#### msubu rs, rt

    {HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为无符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中

#### div rs, rt

    {HI, LO} <- rs / rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为有符号数进行除法运算，将商保存到寄存器LO，余数保存到寄存器HI。

#### divu rs, rt

    {HI, LO} <- rs / rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为无符号数进行除法运算，将商保存到寄存器LO，余数保存到寄存器 HI。

#### jr rs

    pc <- rs，将地址为rs的通用寄存器的值赋给寄存器PC，作为新的指令地址

#### jalr rs 或者jalr rd, rs

    rd <- return_address, pc <- rs，将地址为rs的通用寄存器的值赋给寄存器PC，作为新的指令地址，同时将跳转指令后面第2条指令的地址作为返回地址保存到地址为rd的通用寄存器，如果没有在指令中指明rd，那么默认将返回地址保存到寄存器$31

### j target

    pc <- (pc+4)[31,28] || target || ‘00’，转移到新的指令地址，其中新指令地址的低28位是指令中的target（也就是图8-3中的instr_index）左移两位的值，新指令地址的高4位是跳转指令后面延迟槽指令的地址高4位

### jal target

    pc <- (pc+4)[31,28] || target || ‘00’，转移到新的指令地址，新指令地址与指令j相同，不再解释。但是，指令jal还要将跳转指令后面第2条指令的地址作为返回地址保存到寄存器$31

### beq rs, rt, offset

    if rs = rt then branch，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值进行比较，如果相等，那么发生转移

### b offset

    无条件转移，b指令可以认为是beq指令的特殊情况，当beq指令的rs、rt都等于0时，即为b指令，所以在OpenMIPS实现的时候不需要特意实现b指令，只需要实现beq指令即可

### bgtz rs, offset

    if rs > 0 then branch，如果地址为rs的通用寄存器的值大于零，那么发生转移

### blez rs, offset

    if rs ≤ 0 then branch，如果地址为rs的通用寄存器的值小于等于零，那么发生转移

### bne rs, rt, offset

    if rs ≠ rt then branch，如果地址为rs的通用寄存器的值不等于地址为rt的通用寄存器的值，那么发生转移

### bltz rs, offset

    if rs < 0 then branch，如果地址为rs的通用寄存器的值小于0，那么发生转移

### bltzal rs, offset

    if rs < 0 then branch，如果地址为rs的通用寄存器的值小于0，那么发生转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31

### bgez rs, offset

    if rs ≥ 0 then branch，如果地址为rs的通用寄存器的值大于等于0，那么发生转移

### bgezal rs, offset

    if rs ≥ 0 then branch，如果地址为rs的通用寄存器的值大于等于0，那么发生转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31

### bal offset

    无条件转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31。bal指令是bgezal指令的特殊情况，当bgezal指令的rs为0时，就是bal指令，所以在OpenMIPS实现时，不用特意考虑bal指令，只要实现bgezal指令即可

### lb rt, offset(base) 与base寄存器相加 写入rt

    从内存中指定的加载地址处，读取一个字节，然后符号扩展至32位，保存到地址为rt的通用寄存器中

### lbu rt, offset(base)

    从内存中指定的加载地址处，读取一个字节，然后无符号扩展至32位，保存到地址为rt的通用寄存器中

### lh rt, offset(base)

    从内存中指定的加载地址处，读取一个半字，然后符号扩展至32位，保存到地址为rt的通用寄存器中。该指令有地址对齐要求，要求加载地址的最低位为0

### lhu rt, offset(base)

    从内存中指定的加载地址处，读取一个半字，然后无符号扩展至32位，保存到地址为rt的通用寄存器中。该指令有地址对齐要求，要求加载地址的最低位为0

### lw rt, offset(base)

    从内存中指定的加载地址处，读取一个字，保存到地址为rt的通用寄存器中。该指令有地址对齐要求，要求加载地址的最低两位为00

### sb rt, offset(base)

    将地址为rt的通用寄存器的最低字节存储到内存中的指定地址

### sh rt, offset(base)

    将地址为rt的通用寄存器的最低两个字节存储到内存中的指定地址。该指令有地址对齐要求，要求计算出来的存储地址的最低位为0

### sw rt, offset(base)

    将地址为rt的通用寄存器的值存储到内存中的指定地址。该指令有地址对齐要求，要求计算出来的存储地址的最低两位为00

### lwl rt, offset(base)

    从内存中指定的加载地址处，加载一个字的最高有效部分。lwl指令对加载地址没有要求，从而允许地址非对齐加载，这是与前面介绍的lh、lhu、lw指令的不同之处。在大端模式、小端模式下，lwl指令的效果不同，因为OpenMIPS是大端模式，所以此处只介绍在大端模式下lwl指令的效果。假设计算出来的加载地址是loadaddr，loadaddr的最低两位的值为n，将loadaddr最低两位设为0后的值称为loadaddr_align

### lwr rt, offset(base)

    从内存中指定的加载地址处，加载一个字的最低有效部分。还是假设计算出来的加载地址是loadaddr，loadaddr的最低两位的值为n，将loadaddr最低两位设为0后的值称为loadaddr_align

### swl rt, offset(base)

    将地址为rt的通用寄存器的高位部分存储到内存中指定的地址处，存储地址的最后两位确定了要存储rt通用寄存器的哪几个字节。swl指令对存储地址没有对齐要求，这是与前面介绍的sh、sw指令的不同之处。在大端模式、小端模式下，swl指令的效果不同，因为OpenMIPS是大端模式，所以此处只介绍在大端模式下swl指令的效果。假设计算出来的存储地址是storeaddr，storeaddr最低两位的值为n，storeaddr最低两位设为0后的值称为storeaddr_align，

### swr rt, offset(base)

    将地址为rt的通用寄存器的低位部分存储到内存中指定的地址处，存储地址的最后两位确定了要存储rt通用寄存器的哪几个字节。还是假设计算出来的存储地址是storeaddr，storeaddr的最低两位的值为n，storeaddr最低两位设为0后的值称为storeaddr_align