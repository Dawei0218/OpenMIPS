### 汇编指令




### ori rs, rt, immediate

    32-26   25-21   20-16   15-0
    001101    rs      rt    immediate
    immediate无符号扩展至32位，和rs进行或操作，保存到rt

#### movn rd, rs, rt

    if rt ≠0 then rd <- rs

#### movz

    if rt = 0 then rd <- rs

#### mfhi rd

    rd <- hi

#### mflo rd

    rd <- lo

#### mthi rs

    hi <- rs

#### mtlo rs

    lo <- rs

#### add rd, rs, rt

    rd <- rs + rt   溢出不保存结果

#### addu rd, rs, rt

    rd <- rs + rt   不进行溢出检查，总是保存到寄存器

#### sub rd, rs, rt

    rd <- rs - rt   溢出不保存结果

#### subu rd, rs, rt

    rd <- rs - rt   不进行溢出检查，总是保存到寄存器

#### slt rd, rs, rt

    rd <- (rs < rt) 有符号比较，吧0或1保存在rd

#### sltu rd, rs, rt

    rd <- (rs < rt) 无符号比较

#### addi rt, rs, immediate

    rt <- rs + (sign_extended)immediate

#### addiu rt, rs, immediate

    rt <- rs + (sign_extended)immediate

#### slti rt, rs, immediate

    rt <- (rs < (sign_extended)immediate)

#### sltiu rt, rs, immediate

    rt<- (rs < (sign_extended)immediate)

#### clz rd, rs

    rd <- coun_leading_zeros rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“1”的位，将该位之前“0”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为0（即0x00000000），那么将32保存到地址为rd的通用寄存器中

#### rd <- coun_leading_ones rs

    rd <- coun_leading_ones rs
    对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“0”的位，将该位之前“1”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为1（即0xFFFFFFFF），那么将32保存到地址为rd的通用寄存器中

#### mul rd, rs, st

    rd <- rs × rt

#### mult rs, st

    {hi, lo} <- rs × rt
    将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数相乘，乘法结果的低32bit保存到LO寄存器中，高32bit保存到HI寄存器中

#### multu rs, st

    {hi, lo} <- rs × rt
    无符号相乘

#### madd rs, rd

    {HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。此处{HI, LO}表示HI、LO寄存器连接形成的64位数，HI是高32位，LO是低32位。

#### maddu rs, rt

    {HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为无符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。

#### msub rs, rt

    {HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为有符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中

#### msubu rs, rt

    {HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值作为无符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中

#### div rs, rt

    {HI, LO} <- rs / rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为有符号数进行除法运算，将商保存到寄存器LO，余数保存到寄存器HI。

#### divu rs, rt

    {HI, LO} <- rs / rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为无符号数进行除法运算，将商保存到寄存器LO，余数保存到寄存器HI。

#### jr rs

    pc <- rs，将地址为rs的通用寄存器的值赋给寄存器PC，作为新的指令地址

#### jalr rs 或者jalr rd, rs

    rd <- return_address, pc <- rs，将地址为rs的通用寄存器的值赋给寄存器PC，作为新的指令地址，同时将跳转指令后面第2条指令的地址作为返回地址保存到地址为rd的通用寄存器，如果没有在指令中指明rd，那么默认将返回地址保存到寄存器$31

### j target

    pc <- (pc+4)[31,28] || target || ‘00’，转移到新的指令地址，其中新指令地址的低28位是指令中的target（也就是图8-3中的instr_index）左移两位的值，新指令地址的高4位是跳转指令后面延迟槽指令的地址高4位

### jal target

    pc <- (pc+4)[31,28] || target || ‘00’，转移到新的指令地址，新指令地址与指令j相同，不再解释。但是，指令jal还要将跳转指令后面第2条指令的地址作为返回地址保存到寄存器$31

### beq rs, rt, offset

    if rs = rt then branch，将地址为rs的通用寄存器的值与地址为rt的通用寄存器的值进行比较，如果相等，那么发生转移

### b offset

    无条件转移，b指令可以认为是beq指令的特殊情况，当beq指令的rs、rt都等于0时，即为b指令，所以在OpenMIPS实现的时候不需要特意实现b指令，只需要实现beq指令即可

### bgtz rs, offset

    if rs > 0 then branch，如果地址为rs的通用寄存器的值大于零，那么发生转移

### blez rs, offset

    if rs ≤ 0 then branch，如果地址为rs的通用寄存器的值小于等于零，那么发生转移

### bne rs, rt, offset

    if rs ≠ rt then branch，如果地址为rs的通用寄存器的值不等于地址为rt的通用寄存器的值，那么发生转移

### bltz rs, offset

    if rs < 0 then branch，如果地址为rs的通用寄存器的值小于0，那么发生转移

### bltzal rs, offset

    if rs < 0 then branch，如果地址为rs的通用寄存器的值小于0，那么发生转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31

### bgez rs, offset

    if rs ≥ 0 then branch，如果地址为rs的通用寄存器的值大于等于0，那么发生转移

### bgezal rs, offset

    if rs ≥ 0 then branch，如果地址为rs的通用寄存器的值大于等于0，那么发生转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31

### bal offset

    无条件转移，并且将转移指令后面第2条指令的地址作为返回地址，保存到通用寄存器$31。bal指令是bgezal指令的特殊情况，当bgezal指令的rs为0时，就是bal指令，所以在OpenMIPS实现时，不用特意考虑bal指令，只要实现bgezal指令即可

### lb rt, offset(base) 与base寄存器相加 写入rt

    从内存中指定的加载地址处，读取一个字节，然后符号扩展至32位，保存到地址为rt的通用寄存器中

### lbu rt, offset(base)

    从内存中指定的加载地址处，读取一个字节，然后无符号扩展至32位，保存到地址为rt的通用寄存器中

### lh rt, offset(base)

    从内存中指定的加载地址处，读取一个半字，然后符号扩展至32位，保存到地址为rt的通用寄存器中。该指令有地址对齐要求，要求加载地址的最低位为0

### lhu rt, offset(base)

    从内存中指定的加载地址处，读取一个半字，然后无符号扩展至32位，保存到地址为rt的通用寄存器中。该指令有地址对齐要求，要求加载地址的最低位为0

### lw rt, offset(base)

    从内存中指定的加载地址处，读取一个字，保存到地址为rt的通用寄存器中。该指令有地址对齐要求，要求加载地址的最低两位为00

### sb rt, offset(base)

    将地址为rt的通用寄存器的最低字节存储到内存中的指定地址

### sh rt, offset(base)

    将地址为rt的通用寄存器的最低两个字节存储到内存中的指定地址。该指令有地址对齐要求，要求计算出来的存储地址的最低位为0

### sw rt, offset(base)

    将地址为rt的通用寄存器的值存储到内存中的指定地址。该指令有地址对齐要求，要求计算出来的存储地址的最低两位为00

### lwl rt, offset(base)

    从内存中指定的加载地址处，加载一个字的最高有效部分。lwl指令对加载地址没有要求，从而允许地址非对齐加载，这是与前面介绍的lh、lhu、lw指令的不同之处。在大端模式、小端模式下，lwl指令的效果不同，因为OpenMIPS是大端模式，所以此处只介绍在大端模式下lwl指令的效果。假设计算出来的加载地址是loadaddr，loadaddr的最低两位的值为n，将loadaddr最低两位设为0后的值称为loadaddr_align

### lwr rt, offset(base)

    从内存中指定的加载地址处，加载一个字的最低有效部分。还是假设计算出来的加载地址是loadaddr，loadaddr的最低两位的值为n，将loadaddr最低两位设为0后的值称为loadaddr_align

### swl rt, offset(base)

    将地址为rt的通用寄存器的高位部分存储到内存中指定的地址处，存储地址的最后两位确定了要存储rt通用寄存器的哪几个字节。swl指令对存储地址没有对齐要求，这是与前面介绍的sh、sw指令的不同之处。在大端模式、小端模式下，swl指令的效果不同，因为OpenMIPS是大端模式，所以此处只介绍在大端模式下swl指令的效果。假设计算出来的存储地址是storeaddr，storeaddr最低两位的值为n，storeaddr最低两位设为0后的值称为storeaddr_align，

### swr rt, offset(base)

    将地址为rt的通用寄存器的低位部分存储到内存中指定的地址处，存储地址的最后两位确定了要存储rt通用寄存器的哪几个字节。还是假设计算出来的存储地址是storeaddr，storeaddr的最低两位的值为n，storeaddr最低两位设为0后的值称为storeaddr_align